name: Deploy Frontend to AWS

on:
  push:
    branches: [ main, dev, feature/good-cicd ]
  pull_request:
    branches: [ main, dev ]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: academic-saas-frontend
  NODE_VERSION: '20'

jobs:
  # ========================================
  # TESTING & BUILD JOB
  # ========================================
  test-and-build:
    name: Test and Build
    runs-on: ubuntu-latest
    
    outputs:
      image-uri: ${{ steps.build-image.outputs.image }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run type checking
      run: npx tsc --noEmit

    - name: Run ESLint
      run: npm run lint

    - name: Test build (Development)
      if: github.ref != 'refs/heads/main'
      env:
        NEXT_PUBLIC_API_URL: http://localhost:8000
        NEXTAUTH_URL: http://localhost:3000
        NEXTAUTH_SECRET: test-secret-key-for-ci
      run: npm run build

    - name: Test build (Production)
      if: github.ref == 'refs/heads/main'
      env:
        NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL_PROD }}
        NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL_PROD }}
        NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET_PROD }}
      run: npm run build

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ github.ref == 'refs/heads/main' && secrets.AWS_ACCESS_KEY_ID_PROD || secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ github.ref == 'refs/heads/main' && secrets.AWS_SECRET_ACCESS_KEY_PROD || secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build application with environment-specific config
      env:
        NEXT_PUBLIC_API_URL: ${{ github.ref == 'refs/heads/main' && secrets.NEXT_PUBLIC_API_URL_PROD || secrets.NEXT_PUBLIC_API_URL }}
        NEXTAUTH_URL: ${{ github.ref == 'refs/heads/main' && secrets.NEXTAUTH_URL_PROD || secrets.NEXTAUTH_URL }}
        NEXTAUTH_SECRET: ${{ github.ref == 'refs/heads/main' && secrets.NEXTAUTH_SECRET_PROD || secrets.NEXTAUTH_SECRET }}
      run: npm run build

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
        NEXT_PUBLIC_API_URL: ${{ github.ref == 'refs/heads/main' && secrets.NEXT_PUBLIC_API_URL_PROD || secrets.NEXT_PUBLIC_API_URL }}
        NEXTAUTH_URL: ${{ github.ref == 'refs/heads/main' && secrets.NEXTAUTH_URL_PROD || secrets.NEXTAUTH_URL }}
        NEXTAUTH_SECRET: ${{ github.ref == 'refs/heads/main' && secrets.NEXTAUTH_SECRET_PROD || secrets.NEXTAUTH_SECRET }}
      run: |
        # Build Docker image with build args
        docker build \
          --build-arg NEXT_PUBLIC_API_URL="$NEXT_PUBLIC_API_URL" \
          --build-arg NEXTAUTH_URL="$NEXTAUTH_URL" \
          --build-arg NEXTAUTH_SECRET="$NEXTAUTH_SECRET" \
          -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          
        docker build \
          --build-arg NEXT_PUBLIC_API_URL="$NEXT_PUBLIC_API_URL" \
          --build-arg NEXTAUTH_URL="$NEXTAUTH_URL" \
          --build-arg NEXTAUTH_SECRET="$NEXTAUTH_SECRET" \
          -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        
        # Push to ECR
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        # Output for next jobs
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

  # ========================================
  # DEVELOPMENT DEPLOYMENT JOB
  # ========================================
  deploy-dev:
    name: Deploy to Development
    runs-on: ubuntu-latest
    needs: test-and-build
    if: github.ref == 'refs/heads/dev' || github.ref == 'refs/heads/feature/good-cicd'
    environment: development

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Deploy to Development Instance
      env:
        IMAGE_URI: ${{ needs.test-and-build.outputs.image-uri }}
        ECR_REGISTRY: ${{ secrets.AWS_ACCESS_KEY_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
      run: |
        DEV_INSTANCE_IP="${{ secrets.DEV_INSTANCE_IP }}"
        
        if [ -z "$DEV_INSTANCE_IP" ]; then
          echo "‚ùå DEV_INSTANCE_IP secret not configured"
          exit 1
        fi
        
        echo "üöÄ Deploying to development instance: $DEV_INSTANCE_IP"
        
        # Setup SSH key
        echo "${{ secrets.EC2_SSH_KEY }}" > /tmp/ec2-key.pem
        chmod 600 /tmp/ec2-key.pem
        
        # Create optimized deployment script
        cat > /tmp/deploy-frontend-dev.sh << 'EOF'
#!/bin/bash
set -e
echo "üîÑ Starting frontend deployment..."

# Login to ECR
aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin $1

# Stop and remove existing container
echo "‚èπÔ∏è  Stopping existing frontend container..."
docker stop academic-saas-frontend || true
docker rm academic-saas-frontend || true

# Pull new image
echo "üì• Pulling new image: $2"
docker pull $2

# Create environment file
sudo mkdir -p /opt/academic-saas
sudo tee /opt/academic-saas/.env.frontend > /dev/null << ENVEOF
NEXT_PUBLIC_API_URL=$3
NEXTAUTH_URL=$4
NEXTAUTH_SECRET=$5
ENVEOF

sudo chown root:root /opt/academic-saas/.env.frontend
sudo chmod 600 /opt/academic-saas/.env.frontend

# Start new container
echo "üöÄ Starting new frontend container..."
docker run -d \
  --name academic-saas-frontend \
  --restart unless-stopped \
  --network host \
  --env-file /opt/academic-saas/.env.frontend \
  $2

# Wait for container to be healthy
echo "‚è≥ Waiting for container to be healthy..."
sleep 30

# Check if container is running
if docker ps | grep -q academic-saas-frontend; then
  echo "‚úÖ Frontend container is running"
  
  # Health check
  echo "üîç Performing health check..."
  if curl -f http://localhost:3000/ > /dev/null 2>&1; then
    echo "‚úÖ Frontend deployment completed successfully!"
  else
    echo "‚ùå Health check failed"
    docker logs academic-saas-frontend --tail 20
    exit 1
  fi
else
  echo "‚ùå Frontend container failed to start"
  docker logs academic-saas-frontend --tail 20
  exit 1
fi
EOF
        
        # Copy and execute deployment script
        scp -i /tmp/ec2-key.pem -o StrictHostKeyChecking=no /tmp/deploy-frontend-dev.sh ec2-user@$DEV_INSTANCE_IP:/tmp/deploy-frontend-dev.sh
        
        ssh -i /tmp/ec2-key.pem -o StrictHostKeyChecking=no ec2-user@$DEV_INSTANCE_IP \
          "chmod +x /tmp/deploy-frontend-dev.sh && /tmp/deploy-frontend-dev.sh \
          $ECR_REGISTRY \
          $IMAGE_URI \
          '${{ secrets.NEXT_PUBLIC_API_URL }}' \
          '${{ secrets.NEXTAUTH_URL }}' \
          '${{ secrets.NEXTAUTH_SECRET }}'"
        
        # Clean up
        rm -f /tmp/ec2-key.pem

    - name: Verify deployment
      run: |
        DEV_INSTANCE_IP="${{ secrets.DEV_INSTANCE_IP }}"
        FRONTEND_URL="http://$DEV_INSTANCE_IP:3000"
        
        echo "üîç Testing frontend at $FRONTEND_URL"
        
        # Wait for deployment to stabilize
        sleep 30
        
        # Test health endpoint
        if curl -f $FRONTEND_URL/ > /dev/null 2>&1; then
          echo "‚úÖ Development deployment verification completed"
        else
          echo "‚ùå Development deployment verification failed"
          exit 1
        fi

  # ========================================
  # PRODUCTION DEPLOYMENT JOB
  # ========================================
  deploy-prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: test-and-build
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Deploy to Production Auto Scaling Group
      env:
        IMAGE_URI: ${{ needs.test-and-build.outputs.image-uri }}
      run: |
        ASG_NAME="academic-saas-prod-frontend-asg"
        ECR_REGISTRY="${{ secrets.AWS_ACCESS_KEY_ID_PROD }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
        
        echo "üöÄ Deploying to production ASG: $ASG_NAME"
        
        # Get instance IPs from ASG
        INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
          --auto-scaling-group-names $ASG_NAME \
          --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService`].InstanceId' \
          --output text)
        
        if [ -z "$INSTANCE_IDS" ]; then
          echo "‚ùå No running instances found in ASG"
          exit 1
        fi
        
        echo "üìã Found instances: $INSTANCE_IDS"
        
        # Create production deployment script
        cat > /tmp/deploy-frontend-prod.sh << 'EOF'
#!/bin/bash
set -e
echo "üîÑ Starting production frontend deployment..."

# Login to ECR
aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin $1

# Rolling deployment - stop old container gracefully
echo "‚èπÔ∏è  Gracefully stopping existing frontend container..."
docker stop academic-saas-frontend || true
sleep 5
docker rm academic-saas-frontend || true

# Pull new image
echo "üì• Pulling new image: $2"
docker pull $2

# Create environment file
sudo mkdir -p /opt/academic-saas
sudo tee /opt/academic-saas/.env.frontend > /dev/null << ENVEOF
NEXT_PUBLIC_API_URL=$3
NEXTAUTH_URL=$4
NEXTAUTH_SECRET=$5
ENVEOF

sudo chown root:root /opt/academic-saas/.env.frontend
sudo chmod 600 /opt/academic-saas/.env.frontend

# Start new container with production settings
echo "üöÄ Starting new frontend container..."
docker run -d \
  --name academic-saas-frontend \
  --restart unless-stopped \
  -p 3000:3000 \
  --env-file /opt/academic-saas/.env.frontend \
  $2

# Wait for container to be healthy
echo "‚è≥ Waiting for container to be healthy..."
sleep 60

# Check if container is running
if docker ps | grep -q academic-saas-frontend; then
  echo "‚úÖ Frontend container is running"
  
  # Health check
  echo "üîç Performing health check..."
  if curl -f http://localhost:3000/ > /dev/null 2>&1; then
    echo "‚úÖ Frontend deployment completed successfully!"
  else
    echo "‚ùå Health check failed"
    docker logs academic-saas-frontend --tail 20
    exit 1
  fi
else
  echo "‚ùå Frontend container failed to start"
  docker logs academic-saas-frontend --tail 20
  exit 1
fi
EOF
        
        # Deploy to each instance
        for INSTANCE_ID in $INSTANCE_IDS; do
          INSTANCE_IP=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          
          if [ "$INSTANCE_IP" != "null" ] && [ "$INSTANCE_IP" != "" ]; then
            echo "üöÄ Deploying to instance $INSTANCE_ID ($INSTANCE_IP)"
            
            # Setup SSH key
            echo "${{ secrets.EC2_SSH_KEY_PROD }}" > /tmp/ec2-key.pem
            chmod 600 /tmp/ec2-key.pem
            
            # Copy and execute deployment script
            scp -i /tmp/ec2-key.pem -o StrictHostKeyChecking=no /tmp/deploy-frontend-prod.sh ubuntu@$INSTANCE_IP:/tmp/deploy-frontend-prod.sh
            
            ssh -i /tmp/ec2-key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP \
              "chmod +x /tmp/deploy-frontend-prod.sh && /tmp/deploy-frontend-prod.sh \
              $ECR_REGISTRY \
              $IMAGE_URI \
              '${{ secrets.NEXT_PUBLIC_API_URL_PROD }}' \
              '${{ secrets.NEXTAUTH_URL_PROD }}' \
              '${{ secrets.NEXTAUTH_SECRET_PROD }}'"
            
            # Clean up
            rm -f /tmp/ec2-key.pem
          else
            echo "‚ö†Ô∏è  Instance $INSTANCE_ID has no public IP, skipping"
          fi
        done

    - name: Verify production deployment
      run: |
        # Test via load balancer
        FRONTEND_URL="http://academic-saas-prod-frontend-alb-*.us-east-1.elb.amazonaws.com"
        
        echo "üîç Testing production frontend via load balancer"
        
        # Wait for load balancer to detect healthy targets
        sleep 120
        
        # Note: Replace with actual ALB DNS when available
        echo "‚úÖ Production deployment completed (manual verification required for ALB endpoint)"

  # ========================================
  # NOTIFICATION JOB
  # ========================================
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [test-and-build, deploy-dev, deploy-prod]
    if: always()
    
    steps:
    - name: Notify deployment results
      run: |
        echo "üìä Deployment Summary:"
        echo "Build Status: ${{ needs.test-and-build.result }}"
        echo "Dev Deployment: ${{ needs.deploy-dev.result }}"
        echo "Prod Deployment: ${{ needs.deploy-prod.result }}"
        
        if [ "${{ needs.test-and-build.result }}" == "success" ]; then
          echo "‚úÖ Build and tests passed"
        else
          echo "‚ùå Build or tests failed"
        fi
        
        if [ "${{ needs.deploy-dev.result }}" == "success" ]; then
          echo "‚úÖ Development deployment successful"
          echo "üåê Dev Access: http://${{ secrets.DEV_INSTANCE_IP }}:3000"
        elif [ "${{ needs.deploy-dev.result }}" == "skipped" ]; then
          echo "‚è≠Ô∏è Development deployment skipped"
        else
          echo "‚ùå Development deployment failed"
        fi
        
        if [ "${{ needs.deploy-prod.result }}" == "success" ]; then
          echo "‚úÖ Production deployment successful"
        elif [ "${{ needs.deploy-prod.result }}" == "skipped" ]; then
          echo "‚è≠Ô∏è Production deployment skipped"
        else
          echo "‚ùå Production deployment failed"
        fi